# Clarificaci√≥n: M√©todos de C√°lculo de Free Energy (ŒîG)

**Autor**: Asistente IA - Preparaci√≥n para reuni√≥n con la doctora  
**Fecha**: 2025  
**Prop√≥sito**: Corregir confusi√≥n conceptual entre enhanced sampling y m√©todos alqu√≠micos

---

## üö® CORRECCI√ìN CR√çTICA

### Tu argumento original conten√≠a un error conceptual:

> "si quisi√©ramos calcular delta g **mejor que umbrella** usar√≠amos **m√©todos alqu√≠micos en metadin√°mica**"

**PROBLEMA DETECTADO**:  
Esto mezcla dos categor√≠as de m√©todos **completamente diferentes** que responden preguntas cient√≠ficas distintas.

---

## 1. C√≥mo Metadin√°mica Calcula ŒîG

### Algoritmo de Metadin√°mica

Metadin√°mica usa un **bias gaussiano acumulativo** que se a√±ade durante la simulaci√≥n:

$$V_{bias}(s, t) = \sum_{t'=0}^{t} h \cdot \exp\left(-\frac{(s(t) - s(t'))^2}{2\sigma^2}\right)$$

Donde:
- $s$ = Collective Variable (CV)
- $h$ = Altura del gaussiano (ej. 1.2 kJ/mol)
- $\sigma$ = Ancho del gaussiano (ej. 0.1 nm)
- $t'$ = Pasos de tiempo donde se deposit√≥ gaussiano

### Teorema Fundamental de Metadin√°mica

En el l√≠mite de convergencia ($t \rightarrow \infty$):

$$V_{bias}(s) \rightarrow -F(s) + \text{constante}$$

Donde $F(s)$ es el **Potential of Mean Force (PMF)**.

**Interpretaci√≥n f√≠sica**:
1. El sistema explora con bias acumulativo
2. Cuando visita regi√≥n ya explorada ‚Üí bias la empuja a salir
3. Eventualmente, el bias "rellena" todos los valles del PMF
4. En convergencia: **bias = -PMF** (perfil invertido)

### Extracci√≥n Pr√°ctica de ŒîG

```python
import numpy as np

def calculate_pmf_from_metad(hills_file, cv_min, cv_max, bins=100):
    """
    Calcula PMF desde archivo de HILLS de metadin√°mica.
    
    Par√°metros:
    -----------
    hills_file : str
        Archivo con gaussianos depositados (time, CV, height, sigma)
    cv_min, cv_max : float
        Rango de la collective variable
    bins : int
        Resoluci√≥n del PMF
    
    Retorna:
    --------
    cv_values : ndarray
        Coordenadas de CV
    pmf : ndarray
        Free energy en kJ/mol
    """
    
    # 1. Leer HILLS (archivo de metadin√°mica)
    hills = np.loadtxt(hills_file)
    times = hills[:, 0]
    cv_centers = hills[:, 1]
    heights = hills[:, 2]
    sigmas = hills[:, 3]
    
    # 2. Crear grid de CV
    cv_values = np.linspace(cv_min, cv_max, bins)
    bias = np.zeros(bins)
    
    # 3. Sumar todos los gaussianos
    for i, cv in enumerate(cv_values):
        for j in range(len(hills)):
            bias[i] += heights[j] * np.exp(
                -(cv - cv_centers[j])**2 / (2 * sigmas[j]**2)
            )
    
    # 4. PMF = -V_bias (teorema de metadin√°mica)
    pmf = -bias
    
    # 5. Normalizar: m√≠nimo = 0
    pmf -= pmf.min()
    
    # 6. Calcular barrera de activaci√≥n
    delta_g = pmf.max() - pmf.min()
    
    print(f"Barrera de activaci√≥n (ŒîG): {delta_g:.2f} kJ/mol")
    
    return cv_values, pmf

# Uso:
cv, pmf = calculate_pmf_from_metad(
    'HILLS', 
    cv_min=2.0, 
    cv_max=4.0, 
    bins=200
)
```

### Well-Tempered Metadynamics (Recomendado)

En la pr√°ctica moderna se usa **well-tempered metadynamics**, que reduce la altura del gaussiano con el tiempo:

$$h(t) = h_0 \cdot \exp\left(-\frac{V_{bias}(s(t), t)}{k_B \Delta T}\right)$$

Donde $\Delta T$ es el "bias factor" (t√≠picamente 10-15 para prote√≠nas).

**Ventaja**: Converge m√°s suavemente, evita sobre-muestreo.

---

## 2. Tres Clases de M√©todos de Free Energy

### A. Enhanced Sampling (Umbrella, Metadin√°mica)

**Pregunta cient√≠fica**: *"¬øCu√°l es el costo energ√©tico de una transici√≥n conformacional?"*

| M√©todo | Tipo de Bias | C√°lculo de ŒîG |
|--------|--------------|---------------|
| **Umbrella Sampling** | Bias arm√≥nico est√°tico: $k(s - s_0)^2$ | WHAM/MBAR sobre ventanas |
| **Metadin√°mica** | Bias gaussiano acumulativo | $-V_{bias}$ en convergencia |
| **ABF** | Bias adaptativo en fuerza | Integraci√≥n de fuerza media |
| **Steered MD** | Bias de pulling | Jarzynski equality |

**Caracter√≠sticas comunes**:
- Aplican bias en el espacio de **collective variables (CV)**
- Calculan **PMF(CV)** = perfil de energ√≠a libre vs. coordenada de reacci√≥n
- Aceleran cruce de barreras energ√©ticas
- **Mismo engine MD** (OpenMM, GROMACS, AMBER) con par√°metros id√©nticos
- **Solo difiere el algoritmo de bias**

**Ejemplo WNK1**:
- CV = Distancia CŒ±(C-term) - CŒ±(N-term)
- Umbrella: 20 ventanas √ó 100 ns = 2 Œºs
- Metadin√°mica: 500 ns continuo con gaussianos cada 1 ps
- **Ambos calculan el mismo ŒîG** (barrera conformacional)

### B. Alchemical Methods (FEP, TI, BAR)

**Pregunta cient√≠fica**: *"¬øCu√°nto cambia ŒîG si transformo qu√≠micamente el sistema?"*

| M√©todo | Par√°metro de Transformaci√≥n | C√°lculo de ŒîG |
|--------|------------------------------|---------------|
| **FEP** (Free Energy Perturbation) | $\lambda$: 0 (estado A) ‚Üí 1 (estado B) | Exponential averaging: $\langle e^{-\Delta U/k_B T} \rangle$ |
| **TI** (Thermodynamic Integration) | $\lambda$: 0 ‚Üí 1 | Integraci√≥n: $\int_0^1 \langle \partial U/\partial \lambda \rangle d\lambda$ |
| **BAR** (Bennett Acceptance Ratio) | $\lambda$: ventanas intermedias | Optimizaci√≥n de solapamiento |

**Transformaciones t√≠picas**:
- **Mutaci√≥n**: Ala ‚Üí Gly (cambiar par√°metros de residuo)
- **Uni√≥n de ligando**: Sin ligando ‚Üí Con ligando (aparecer/desaparecer √°tomos)
- **Solvataci√≥n**: Vac√≠o ‚Üí Agua (calcular ŒîG_solv)

**Caracter√≠sticas clave**:
- Usan par√°metro **Œª** (NO es una CV f√≠sica)
- **Modifican el Hamiltoniano** del sistema durante la simulaci√≥n
- Calculan **ŒîŒîG** de transformaci√≥n qu√≠mica
- Requieren m√∫ltiples ventanas de Œª (t√≠picamente 10-20)

**Ejemplo de mutaci√≥n S1261A en WNK1**:
```python
# Œª = 0: Wildtype (Ser1261)
# Œª = 0.5: Estado intermedio (part√≠culas fantasma)
# Œª = 1: Mutante (Ala1261)

# ŒîŒîG = ŒîG_mutante - ŒîG_wildtype
# Calculado v√≠a TI:
ddG = integrate(dU/dŒª, Œª=0 to 1)
```

### C. Standard MD (drMD, MD Est√°ndar)

**Pregunta cient√≠fica**: *"¬øQu√© conformaciones explora el sistema espont√°neamente?"*

**Caracter√≠sticas**:
- **Sin bias artificial**
- Solo explora seg√∫n Hamiltoniano natural
- **No calcula ŒîG cuantitativamente**
- √ötil para: muestreo, clustering, an√°lisis RMSD, visualizaci√≥n

**Limitaciones**:
- No puede cruzar barreras altas (>15 kJ/mol) en tiempos razonables
- No proporciona valores de ŒîG directamente
- Requiere microsegundos para eventos raros

---

## 3. Comparaci√≥n Directa: ¬øQu√© ŒîG Calcula Cada M√©todo?

| Pregunta Cient√≠fica | M√©todo Apropiado | ŒîG Calculado | Unidades | Tiempo T√≠pico |
|---------------------|------------------|--------------|----------|---------------|
| ¬øBarrera conformacional abierto‚Üícerrado? | **Umbrella / Metadin√°mica** | PMF(distancia) | kJ/mol | 1-5 Œºs total |
| ¬øCosto de mutaci√≥n Ser‚ÜíAla? | **FEP / TI / BAR** | ŒîŒîG(mutaci√≥n) | kJ/mol | 50-200 ns |
| ¬øAfinidad de uni√≥n ligando? | **FEP / TI / BAR** | ŒîG(binding) | kJ/mol | 100-500 ns |
| ¬øExploraci√≥n sin cuantificaci√≥n? | **drMD / MD est√°ndar** | Ninguno (cualitativo) | - | 100-1000 ns |
| ¬øValidaci√≥n cruzada de PMF? | **Umbrella + Metadin√°mica** | PMF(CV) √ó 2 | kJ/mol | 2√ó tiempo |

---

## 4. Correcci√≥n del Argumento para la Doctora

### ‚ùå Versi√≥n Original (INCORRECTA)

> "drMD no tiene umbrella, no podemos correrlo para correr delta g porque no calcula delta g como tal como umbrella, **y si quisi√©ramos calcular delta g mejor que umbrella usar√≠amos m√©todos alqu√≠micos en metadin√°mica**"

**Errores conceptuales**:
1. ‚ùå "m√©todos alqu√≠micos EN metadin√°mica" ‚Üí No existe tal cosa
2. ‚ùå "mejor que umbrella" ‚Üí Metadin√°mica no es "mejor", es alternativo (mismo resultado)
3. ‚ùå Implica que alqu√≠micos calculan PMF conformacional ‚Üí NO, calculan ŒîŒîG de transformaciones qu√≠micas

---

### ‚úÖ Versi√≥n Corregida (CORRECTA)

**Parte 1 - Limitaciones de drMD** (mantener):
> "drMD es excelente para exploraci√≥n conformacional y tiene validaciones robustas (pdbTriage, FirstAid, clustering autom√°tico), pero **no tiene m√©todos de enhanced sampling integrados** (umbrella, metadin√°mica, ABF). Por lo tanto, no puede cuantificar barreras de energ√≠a libre directamente."

**Parte 2 - Justificaci√≥n de Umbrella Sampling** (nuevo):
> "Para cuantificar el **ŒîG de la transici√≥n conformacional** del C-terminal de WNK1 (conformaci√≥n abierta ‚Üí cerrada), necesitamos un m√©todo de **enhanced sampling** que calcule el Potential of Mean Force (PMF). Seleccion√© **umbrella sampling** por las siguientes razones:
> 
> 1. **CV bien definida**: La distancia CŒ±-CŒ± terminal es una coordenada de reacci√≥n natural
> 2. **Barreras altas**: Estimamos ~25 kJ/mol (requiere enhanced sampling)
> 3. **Paralelizaci√≥n eficiente**: 20 ventanas √ó 4 CPUs = uso √≥ptimo de nuestro HPC de 48 cores
> 4. **M√©todo establecido**: Extensa validaci√≥n en literatura para transiciones conformacionales
> 5. **Post-an√°lisis robusto**: MBAR proporciona errores estad√≠sticos bien definidos"

**Parte 3 - Validaci√≥n Opcional** (nuevo):
> "Como validaci√≥n cruzada, podr√≠amos implementar **metadin√°mica** (otro m√©todo de enhanced sampling) para verificar el mismo PMF. Ambos m√©todos usan el mismo engine de MD (OpenMM) con par√°metros f√≠sicos id√©nticos, solo difieren en el algoritmo de bias (arm√≥nico vs. gaussiano acumulativo). Esperar√≠amos RMSD < 2 kJ/mol entre ambos perfiles."

**Parte 4 - Cu√°ndo Usar Alqu√≠micos** (nuevo):
> "Los **m√©todos alqu√≠micos** (FEP, TI, BAR) son apropiados para preguntas cient√≠ficas **diferentes**:
> 
> - ¬øC√≥mo afecta la mutaci√≥n S1261A a la estabilidad? ‚Üí **TI/FEP** (ŒîŒîG de mutaci√≥n)
> - ¬øCu√°l es la afinidad de uni√≥n de ATP? ‚Üí **FEP** (ŒîG_binding)
> - ¬øC√≥mo cambia ŒîG_solv al mutar? ‚Üí **BAR** (ŒîŒîG_solv)
> 
> Estos m√©todos usan transformaciones qu√≠micas v√≠a par√°metro Œª, NO calculan PMF de transiciones conformacionales. Para nuestro objetivo actual (barrera conformacional), **no son aplicables**."

---

## 5. Argumento Completo Listo para Defender

### Flujo L√≥gico

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PREGUNTA CIENT√çFICA:                                    ‚îÇ
‚îÇ ¬øCu√°l es el costo energ√©tico (ŒîG) de la transici√≥n     ‚îÇ
‚îÇ conformacional abierta‚Üícerrada del C-terminal de WNK1?  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ M√âTODO NECESARIO:                                       ‚îÇ
‚îÇ Enhanced Sampling (calcula PMF vs. CV)                  ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ Opciones:                                               ‚îÇ
‚îÇ ‚Ä¢ Umbrella Sampling ‚Üê SELECCIONADO                      ‚îÇ
‚îÇ ‚Ä¢ Metadin√°mica (validaci√≥n opcional)                    ‚îÇ
‚îÇ ‚Ä¢ ABF (menos com√∫n en prote√≠nas)                        ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ NO APLICABLE:                                           ‚îÇ
‚îÇ ‚Ä¢ M√©todos alqu√≠micos (FEP/TI/BAR) ‚Üí Para mutaciones     ‚îÇ
‚îÇ ‚Ä¢ drMD est√°ndar ‚Üí Solo exploraci√≥n cualitativa          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ JUSTIFICACI√ìN DE UMBRELLA:                              ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ 1. CV conocida (distancia CŒ±-CŒ±)                        ‚îÇ
‚îÇ 2. Barrera alta (~25 kJ/mol)                            ‚îÇ
‚îÇ 3. Paralelizaci√≥n HPC (48 cores, 20 ventanas)          ‚îÇ
‚îÇ 4. Convergencia verificable (MBAR bootstrap)           ‚îÇ
‚îÇ 5. Literatura establecida (>5000 papers)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                          ‚îÇ
                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ VALIDACI√ìN:                                             ‚îÇ
‚îÇ ‚Ä¢ Convergencia: Error MBAR < 1 kJ/mol                   ‚îÇ
‚îÇ ‚Ä¢ Solapamiento: Histogramas adyacentes con overlap > 5% ‚îÇ
‚îÇ ‚Ä¢ Cross-check: Metadin√°mica (RMSD < 2 kJ/mol esperado) ‚îÇ
‚îÇ ‚Ä¢ Visualizaci√≥n: VideoSuite + 4-panel diagnostics      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 6. Cu√°ndo S√ç Usar M√©todos Alqu√≠micos

### Ejemplos de Preguntas Apropiadas

1. **Efecto de mutaciones puntuales**:
   ```
   Pregunta: ¬øC√≥mo la mutaci√≥n S1261A afecta la estabilidad de WNK1?
   M√©todo: TI/FEP
   Œª-pathway: Wildtype (Œª=0) ‚Üí Mutante (Œª=1)
   Resultado: ŒîŒîG_fold = ŒîG_mutante - ŒîG_wildtype
   ```

2. **Afinidad de uni√≥n de ligando**:
   ```
   Pregunta: ¬øCu√°l es el ŒîG de uni√≥n de ATP a WNK1?
   M√©todo: FEP con doble transformaci√≥n
   Œª-pathway 1: ATP en agua ‚Üí desaparece (ŒîG_solv)
   Œª-pathway 2: ATP en prote√≠na ‚Üí desaparece (ŒîG_complex)
   Resultado: ŒîG_binding = ŒîG_complex - ŒîG_solv
   ```

3. **Energ√≠a de solvataci√≥n**:
   ```
   Pregunta: ¬øC√≥mo cambia ŒîG_solv al sustituir Ser por Ala?
   M√©todo: BAR
   Œª-pathway: Ser solvatada ‚Üí Ala solvatada
   Resultado: ŒîŒîG_solv
   ```

### Estructura de Œª-Pathway

```python
# Ejemplo de FEP para mutaci√≥n S1261A
lambda_windows = np.linspace(0, 1, 20)

for Œª in lambda_windows:
    # Interpolaci√≥n de par√°metros
    charges = (1-Œª) * charges_Ser + Œª * charges_Ala
    vdw_params = (1-Œª) * vdw_Ser + Œª * vdw_Ala
    
    # Soft-core para evitar singularidades
    U_vdw = 4Œµ[(œÉ/(r^6 + Œ±(1-Œª)^2))^2 - (œÉ/(r^6 + Œ±(1-Œª)^2))]
    
    # Calcular dU/dŒª
    dU_dlambda = U(Œª+Œ¥) - U(Œª-Œ¥) / (2Œ¥)
    
    # Almacenar para TI
    store(Œª, dU_dlambda)

# Integrar
ŒîG = trapz(dU_dlambda, lambda_windows)
```

---

## 7. Resumen Ejecutivo para la Doctora

### Una Frase:
**"Umbrella sampling calcula el PMF de la transici√≥n conformacional del C-terminal de WNK1; m√©todos alqu√≠micos (FEP/TI) son para transformaciones qu√≠micas (mutaciones, uni√≥n de ligandos), no para barreras conformacionales."**

### Tres Puntos Clave:

1. **Enhanced Sampling vs. Alchemical Methods**:
   - Enhanced sampling (umbrella, metadin√°mica): PMF(CV) para transiciones conformacionales
   - Alchemical (FEP, TI, BAR): ŒîŒîG para transformaciones qu√≠micas
   - **Son clases ortogonales**, no "mejor" una que otra

2. **Por Qu√© Umbrella para WNK1**:
   - CV bien definida (distancia CŒ±-CŒ±)
   - Paralelizaci√≥n √≥ptima en HPC (48 cores)
   - M√©todo gold standard para barreras conformacionales

3. **drMD vs. Enhanced Sampling**:
   - drMD: Exploraci√≥n sin bias (no calcula ŒîG)
   - Tiene validaciones excelentes (pdbTriage, FirstAid)
   - **NO es inferior**, simplemente responde pregunta diferente (cualitativa vs. cuantitativa)

---

## 8. Implementaci√≥n de Metadin√°mica (Validaci√≥n Opcional)

Si la doctora solicita validaci√≥n cruzada, aqu√≠ est√° el c√≥digo listo:

```python
# run_metadynamics_wnk.py
import openmm as mm
from openmm import app, unit
from openmm.app import PDBFile, Modeller, ForceField
import numpy as np

def setup_metadynamics(pdb_file, cv_atoms, output_prefix):
    """
    Configura well-tempered metadynamics para WNK1.
    
    Par√°metros:
    -----------
    pdb_file : str
        PDB equilibrado (ej. 'wnk_pbs_equilibrated.pdb')
    cv_atoms : tuple
        (atom1_index, atom2_index) para distancia CŒ±-CŒ±
    output_prefix : str
        Prefijo para archivos de salida
    """
    
    # Cargar sistema
    pdb = PDBFile(pdb_file)
    forcefield = ForceField('amber14-all.xml', 'amber14/tip3p.xml')
    system = forcefield.createSystem(
        pdb.topology,
        nonbondedMethod=app.PME,
        nonbondedCutoff=1.0*unit.nanometer,
        constraints=app.HBonds
    )
    
    # Definir Collective Variable (distancia)
    cv = mm.CustomBondForce('r')
    cv.addBond(cv_atoms[0], cv_atoms[1], [])
    cv_index = system.addForce(cv)
    
    # Par√°metros de metadin√°mica well-tempered
    height = 1.2  # kJ/mol (altura inicial del gaussiano)
    sigma = 0.05  # nm (ancho del gaussiano)
    biasFactor = 10  # ŒîT para well-tempered
    frequency = 1000  # Depositar cada 1 ps (500 steps)
    
    # Crear bias de metadin√°mica
    metad = mm.BiasVariable(cv_index, 2.0, 4.0, sigma, True)
    meta_force = mm.Metadynamics(
        system, [metad], 310*unit.kelvin, biasFactor,
        height*unit.kilojoules_per_mole, frequency
    )
    
    # Guardar HILLS cada 10 gaussianos
    meta_force.setReportInterval(10)
    meta_force.setReportFile(f'{output_prefix}_HILLS.txt')
    
    # Integrator
    integrator = mm.LangevinMiddleIntegrator(
        310*unit.kelvin,
        1.0/unit.picosecond,
        0.002*unit.picoseconds
    )
    
    # Simulation
    platform = mm.Platform.getPlatformByName('CPU')
    properties = {'Threads': '4'}
    simulation = app.Simulation(
        pdb.topology, system, integrator, platform, properties
    )
    simulation.context.setPositions(pdb.positions)
    
    # Reporters
    simulation.reporters.append(
        app.StateDataReporter(
            f'{output_prefix}_log.txt', 5000,
            step=True, time=True, potentialEnergy=True,
            temperature=True, speed=True
        )
    )
    simulation.reporters.append(
        app.DCDReporter(f'{output_prefix}_trajectory.dcd', 5000)
    )
    
    return simulation, meta_force

# Ejecuci√≥n
if __name__ == '__main__':
    # √çndices de CŒ± terminal (ajustar seg√∫n tu sistema)
    CA_NTERM = 10  # Primer residuo visible
    CA_CTERM = 1250  # √öltimo residuo antes del desorden
    
    sim, metad_force = setup_metadynamics(
        'wnk_pbs_equilibrated.pdb',
        (CA_NTERM, CA_CTERM),
        'metad_wnk'
    )
    
    # Correr 500 ns (250,000,000 steps)
    print("Starting well-tempered metadynamics (500 ns)...")
    sim.step(250000000)
    
    # Guardar estado final
    positions = sim.context.getState(getPositions=True).getPositions()
    with open('metad_wnk_final.pdb', 'w') as f:
        app.PDBFile.writeFile(sim.topology, positions, f)
    
    print("Metadynamics complete. Check metad_wnk_HILLS.txt for bias profile.")
```

### Comparaci√≥n de Resultados

```python
# compare_umbrella_metad.py
import numpy as np
import matplotlib.pyplot as plt

def load_umbrella_pmf(mbar_file):
    """Cargar PMF de umbrella sampling (output de MBAR)."""
    data = np.loadtxt(mbar_file)
    return data[:, 0], data[:, 1], data[:, 2]  # cv, pmf, error

def load_metad_pmf(hills_file, cv_min=2.0, cv_max=4.0, bins=200):
    """Calcular PMF de metadin√°mica desde HILLS."""
    hills = np.loadtxt(hills_file)
    cv_centers = hills[:, 1]
    heights = hills[:, 2]
    sigmas = hills[:, 3]
    
    cv_values = np.linspace(cv_min, cv_max, bins)
    bias = np.zeros(bins)
    
    for i, cv in enumerate(cv_values):
        for j in range(len(hills)):
            bias[i] += heights[j] * np.exp(
                -(cv - cv_centers[j])**2 / (2 * sigmas[j]**2)
            )
    
    pmf = -bias
    pmf -= pmf.min()
    return cv_values, pmf

# Cargar ambos PMFs
cv_umb, pmf_umb, err_umb = load_umbrella_pmf('pmf_final.dat')
cv_met, pmf_met = load_metad_pmf('metad_wnk_HILLS.txt')

# Interpolar metadin√°mica al grid de umbrella
pmf_met_interp = np.interp(cv_umb, cv_met, pmf_met)

# Calcular RMSD
rmsd = np.sqrt(np.mean((pmf_umb - pmf_met_interp)**2))

# Plot
plt.figure(figsize=(10, 6))
plt.plot(cv_umb, pmf_umb, 'o-', label='Umbrella Sampling', linewidth=2)
plt.fill_between(cv_umb, pmf_umb-err_umb, pmf_umb+err_umb, alpha=0.3)
plt.plot(cv_met, pmf_met, 's-', label='Metadin√°mica', linewidth=2)
plt.xlabel('Distancia CŒ±-CŒ± (nm)', fontsize=12)
plt.ylabel('PMF (kJ/mol)', fontsize=12)
plt.title(f'Validaci√≥n Cruzada: RMSD = {rmsd:.2f} kJ/mol', fontsize=14)
plt.legend(fontsize=11)
plt.grid(alpha=0.3)
plt.savefig('umbrella_metad_comparison.png', dpi=300, bbox_inches='tight')
plt.show()

print(f"\n{'='*50}")
print(f"VALIDACI√ìN CRUZADA - UMBRELLA vs. METADIN√ÅMICA")
print(f"{'='*50}")
print(f"RMSD entre perfiles:        {rmsd:.3f} kJ/mol")
print(f"Diferencia en barrera:       {abs(pmf_umb.max() - pmf_met.max()):.3f} kJ/mol")
print(f"Criterio de aceptaci√≥n:      RMSD < 2.0 kJ/mol")
print(f"Resultado:                   {'‚úÖ PASS' if rmsd < 2.0 else '‚ùå FAIL'}")
print(f"{'='*50}\n")
```

---

## 9. Referencias Clave

### Enhanced Sampling:
1. **Umbrella Sampling**: Torrie & Valleau (1977). *J. Comput. Phys.* 23, 187-199.
2. **MBAR**: Shirts & Chodera (2008). *J. Chem. Phys.* 129, 124105.
3. **Metadin√°mica**: Laio & Parrinello (2002). *PNAS* 99, 12562-12566.
4. **Well-Tempered Metad**: Barducci et al. (2008). *Phys. Rev. Lett.* 100, 020603.

### Alchemical Methods:
1. **FEP**: Zwanzig (1954). *J. Chem. Phys.* 22, 1420-1426.
2. **TI**: Kirkwood (1935). *J. Chem. Phys.* 3, 300-313.
3. **BAR**: Bennett (1976). *J. Comput. Phys.* 22, 245-268.
4. **Review**: Mobley & Klimovich (2012). *J. Comput. Aided Mol. Des.* 26, 93-109.

### Best Practices:
- Christ et al. (2010). *J. Chem. Inf. Model.* 50, 1787-1805. (Alchemical workflows)
- Barducci et al. (2011). *WIREs Comput. Mol. Sci.* 1, 826-843. (Metadynamics review)
- Hub et al. (2010). *J. Chem. Theory Comput.* 6, 3713-3720. (WHAM implementation)

---

## 10. Checklist Pre-Reuni√≥n con la Doctora

### Conceptos para Defender:

- [ ] **Entiendo las tres clases de m√©todos**:
  - Enhanced Sampling (umbrella, metadin√°mica) ‚Üí PMF conformacional
  - Alchemical (FEP, TI, BAR) ‚Üí ŒîŒîG de transformaciones qu√≠micas
  - Standard MD (drMD) ‚Üí Exploraci√≥n cualitativa

- [ ] **Puedo explicar por qu√© umbrella para WNK1**:
  - CV conocida (distancia CŒ±-CŒ±)
  - Barrera alta requiere enhanced sampling
  - Paralelizaci√≥n √≥ptima en HPC (48 cores)

- [ ] **S√© cu√°ndo usar m√©todos alqu√≠micos**:
  - Mutaciones puntuales (ej. S1261A)
  - Afinidad de uni√≥n ligando
  - Energ√≠as de solvataci√≥n
  - **NO para barreras conformacionales**

- [ ] **Puedo explicar c√≥mo metadin√°mica calcula ŒîG**:
  - Bias gaussiano acumulativo
  - Teorema: $V_{bias} \rightarrow -PMF$
  - Extracci√≥n pr√°ctica desde archivo HILLS

- [ ] **Entiendo que metadin√°mica ‚â† "mejor que umbrella"**:
  - Son m√©todos alternativos (misma pregunta cient√≠fica)
  - Ambos calculan PMF
  - Umbrella: mejor para paralelizaci√≥n
  - Metadin√°mica: mejor para CVs desconocidas

### Frases Clave para Usar:

‚úÖ **CORRECTO**:
- "Necesitamos enhanced sampling para cuantificar la barrera conformacional"
- "Umbrella sampling calcula el PMF mediante ventanas con bias arm√≥nico"
- "Metadin√°mica es una alternativa que usa bias gaussiano acumulativo"
- "M√©todos alqu√≠micos son para transformaciones qu√≠micas, no conformacionales"
- "drMD es excelente para exploraci√≥n, pero no calcula ŒîG"

‚ùå **EVITAR**:
- "M√©todos alqu√≠micos en metadin√°mica" ‚Üí Mezcla conceptos incorrectamente
- "Metadin√°mica es mejor que umbrella" ‚Üí No es mejor, es diferente
- "drMD no sirve" ‚Üí S√ç sirve, pero para prop√≥sito diferente

---

## Conclusi√≥n

**Mensaje Principal**:  
Umbrella sampling y metadin√°mica son **ambos m√©todos de enhanced sampling** que calculan el mismo tipo de ŒîG (PMF conformacional). Los **m√©todos alqu√≠micos** (FEP/TI/BAR) son una **categor√≠a completamente diferente** para transformaciones qu√≠micas. Para WNK1, necesitas enhanced sampling (umbrella), NO m√©todos alqu√≠micos.

**Argumento Listo**:  
"Seleccion√© umbrella sampling porque cuantifica la barrera conformacional del C-terminal de WNK1 mediante enhanced sampling. drMD es excelente para exploraci√≥n pero no calcula ŒîG. Metadin√°mica ser√≠a una alternativa v√°lida (mismo resultado), pero umbrella se paraleliza mejor en nuestro HPC. M√©todos alqu√≠micos son para preguntas diferentes (mutaciones, uni√≥n de ligandos)."

---

**√âxito en tu reuni√≥n! üöÄ**
